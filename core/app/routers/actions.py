from fastapi import APIRouter, Depends, HTTPException, status, BackgroundTasks
from models import ActionItem, ActionCenterCategory, HelpRequest
import auth
import os
from google import genai
from google.genai import types
from services.marathon_agent import MarathonAgent
import jobs

router = APIRouter(prefix="/actions", tags=["Action Center"])

# Helper to get current user (duplicated from main.py, ideally shared in dependencies.py)
from fastapi.security import OAuth2PasswordBearer
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")

async def get_current_user(token: str = Depends(oauth2_scheme)):
    try:
        return auth.auth.verify_id_token(token, check_revoked=True)
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid credentials")

def get_gemini_client():
    api_key = os.getenv("GEMINI_API_KEY")
    if not api_key:
        return None
    return genai.Client(api_key=api_key)

@router.post("/trigger-agent")
def trigger_agent_debug(current_user: dict = Depends(get_current_user)):
    """
    DEBUG: Force-runs the Marathon Agent cycle for the current user.
    """
    uid = current_user['uid']
    print(f"ðŸ”§ DEBUG: Triggering Marathon Agent for {uid}")
    
    try:
        agent = MarathonAgent()
        agent.run_agent_cycle(uid)
        return {"status": "success", "message": "Agent Run Complete. Check Firestore for updates."}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/{category}", response_model=list[ActionItem])
def get_items(category: ActionCenterCategory, current_user: dict = Depends(get_current_user)):
    """Fetches all items for a specific action category."""
    uid = current_user['uid']
    return auth.get_action_items(uid, category.value)

@router.post("/{category}", response_model=dict)
def add_item(category: ActionCenterCategory, item: ActionItem, background_tasks: BackgroundTasks, current_user: dict = Depends(get_current_user)):
    """Adds a new action item to the user's list."""
    uid = current_user['uid']
    if item.category != category:
        raise HTTPException(status_code=400, detail="Category mismatch")
    
    # Exclude ID (generated by DB)
    data = item.dict(exclude={'id'})
    doc_id = auth.add_action_item(uid, category.value, data)
    
    # Trigger Price Monitor if requested on creation
    if item.monitor_price:
         # Need full item data with ID for check logic
         full_item = data.copy()
         full_item['id'] = doc_id
         full_item['uid'] = uid
         
         background_tasks.add_task(jobs.check_single_item_price, full_item)
         print(f"ðŸš€ Created item {doc_id} with immediate price check.")
         
    return {"status": "success", "id": doc_id}

@router.delete("/{category}/{item_id}", response_model=dict)
def delete_item(category: ActionCenterCategory, item_id: str, current_user: dict = Depends(get_current_user)):
    """Deletes an action item."""
    uid = current_user['uid']
    auth.delete_action_item(uid, category.value, item_id)
    return {"status": "success", "id": item_id}

@router.post("/{category}/{item_id}/help", response_model=dict)
def get_help_for_item(category: ActionCenterCategory, item_id: str, request: HelpRequest, current_user: dict = Depends(get_current_user)):
    """
    Generates Gemini 3 Pro Preview help instructions for a specific claim/benefit.
    Saves the result to the item so it acts as a cache.
    """
    uid = current_user['uid']
    
    # 1. Fetch Item
    item = auth.get_action_item(uid, category.value, item_id)
    if not item:
        raise HTTPException(status_code=404, detail="Item not found")
    
    # 2. Check if help already exists (Cached)
    # The requirement says "The step by step instructions should be saved... so it doesn't need to ask Gemini again"
    # However, if the user sends a NEW request (e.g. they want to update their query), we might want to overwrite.
    # But usually, checking if it exists prevents accidental costs. 
    # Let's assume hitting this endpoint forces a refresh or generation.
    
    client = get_gemini_client()
    if not client:
        raise HTTPException(status_code=503, detail="AI Service Unavailable")

    # 3. Construct Prompt
    # "situation that a user is asking for {category} help on X card with the users additional info provided"
    
    card_name = item.get('card_name', 'Credit Card')
    user_notes = request.user_notes
    
    category_context = category.value.replace("_", " ").title()
    item_details = ""
    
    if category == ActionCenterCategory.CAR_RENTAL:
        item_details = f"Car Rented: {item.get('car_rented')}"
    elif category == ActionCenterCategory.AIRPORT:
        item_details = f"Flight Info: {item.get('flight_info')}"
    elif category == ActionCenterCategory.WARRANTY:
        item_details = f"Item: {item.get('item_bought')}"
    elif category == ActionCenterCategory.CELL_PHONE:
        item_details = f"Phone: {item.get('phone_bought')}"
    
    prompt = f"""
    The user is asking for assistance with **{category_context}** on their **{card_name}**.
    
    TRANSACTION DETAILS:
    Retailer: {item.get('retailer')}
    Date: {item.get('date')}
    Total: ${item.get('total')}
    {item_details}
    
    USER'S SITUATION / ISSUE:
    "{user_notes}"
    
    TASK:
    Provide a **short, super concise, step-by-step instruction set** on how to proceed. 
    The output will be displayed in a mobile app, so formatting must be clean and minimal.
    
    - Focus on exactly what they need to do (e.g., "File a claim at [URL]", "Call 1-800-...", "Upload receipt").
    - Do not give generic advice if specific card details are known (infer from card name if possible, or give general best practice for that issuer).
    - Use clear headings or bullet points.
    """
    
    try:
        response = client.models.generate_content(
            model='gemini-3-flash-preview',
            contents=prompt,
        )
        
        instructions = response.text.strip()
        
        # 4. Save to DB
        auth.update_action_item(uid, category.value, item_id, {
            "help_requested": True,
            "gemini_instructions": instructions
        })
        
        return {"status": "success", "instructions": instructions}
        
    except Exception as e:
        print(f"Gemini Error: {e}")
        raise HTTPException(status_code=500, detail=f"AI Error: {str(e)}")

@router.post("/{category}/{item_id}/monitor", response_model=dict)
def toggle_price_monitoring(category: ActionCenterCategory, item_id: str, monitor: bool, background_tasks: BackgroundTasks, current_user: dict = Depends(get_current_user)):
    """
    Enables/Disables price monitoring for an item.
    Only valid for Price Protection category ideally, but we'll allow it generally if the model supports it.
    If enabling, triggers an immediate background check.
    """
    if category != ActionCenterCategory.PRICE_PROTECTION:
        raise HTTPException(status_code=400, detail="Price monitoring only available for Price Protection items.")
        
    uid = current_user['uid']
    auth.update_action_item(uid, category.value, item_id, {
        "monitor_price": monitor
    })
    
    if monitor:
        # Trigger immediate check
        # We need to construct the 'item' dict that check_single_item_price expects
        # So we fetch it first
        item_data = auth.get_action_item(uid, category.value, item_id)
        if item_data:
             # Add ID (auth.get_action_item might not include it in the dict if it's from doc.to_dict(), usually we add it manually)
             # Let's ensure it has ID and UID
             item_data['id'] = item_id
             item_data['uid'] = uid
             
             background_tasks.add_task(jobs.check_single_item_price, item_data)
             print(f"ðŸš€ Triggered immediate price check for {item_id}")
    
    return {"status": "success", "monitor_price": monitor}

