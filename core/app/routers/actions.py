from fastapi import APIRouter, Depends, HTTPException, status
from models import ActionItem, ActionCenterCategory, HelpRequest
import auth
import os
from google import genai
from google.genai import types

router = APIRouter(prefix="/actions", tags=["Action Center"])

# Helper to get current user (duplicated from main.py, ideally shared in dependencies.py)
from fastapi.security import OAuth2PasswordBearer
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")

async def get_current_user(token: str = Depends(oauth2_scheme)):
    try:
        return auth.auth.verify_id_token(token, check_revoked=True)
    except Exception as e:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid credentials")

def get_gemini_client():
    api_key = os.getenv("GEMINI_API_KEY")
    if not api_key:
        return None
    return genai.Client(api_key=api_key)

@router.get("/{category}", response_model=list[ActionItem])
def get_items(category: ActionCenterCategory, current_user: dict = Depends(get_current_user)):
    """Fetches all items for a specific action category."""
    uid = current_user['uid']
    return auth.get_action_items(uid, category.value)

@router.post("/{category}", response_model=dict)
def add_item(category: ActionCenterCategory, item: ActionItem, current_user: dict = Depends(get_current_user)):
    """Adds a new action item to the user's list."""
    uid = current_user['uid']
    if item.category != category:
        raise HTTPException(status_code=400, detail="Category mismatch")
    
    # Exclude ID (generated by DB)
    data = item.dict(exclude={'id'})
    doc_id = auth.add_action_item(uid, category.value, data)
    return {"status": "success", "id": doc_id}

@router.post("/{category}/{item_id}/help", response_model=dict)
def get_help_for_item(category: ActionCenterCategory, item_id: str, request: HelpRequest, current_user: dict = Depends(get_current_user)):
    """
    Generates Gemini 3 Pro Preview help instructions for a specific claim/benefit.
    Saves the result to the item so it acts as a cache.
    """
    uid = current_user['uid']
    
    # 1. Fetch Item
    item = auth.get_action_item(uid, category.value, item_id)
    if not item:
        raise HTTPException(status_code=404, detail="Item not found")
    
    # 2. Check if help already exists (Cached)
    # The requirement says "The step by step instructions should be saved... so it doesn't need to ask Gemini again"
    # However, if the user sends a NEW request (e.g. they want to update their query), we might want to overwrite.
    # But usually, checking if it exists prevents accidental costs. 
    # Let's assume hitting this endpoint forces a refresh or generation.
    
    client = get_gemini_client()
    if not client:
        raise HTTPException(status_code=503, detail="AI Service Unavailable")

    # 3. Construct Prompt
    # "situation that a user is asking for {category} help on X card with the users additional info provided"
    
    card_name = item.get('card_name', 'Credit Card')
    user_notes = request.user_notes
    
    category_context = category.value.replace("_", " ").title()
    item_details = ""
    
    if category == ActionCenterCategory.CAR_RENTAL:
        item_details = f"Car Rented: {item.get('car_rented')}"
    elif category == ActionCenterCategory.AIRPORT:
        item_details = f"Flight Info: {item.get('flight_info')}"
    elif category == ActionCenterCategory.WARRANTY:
        item_details = f"Item: {item.get('item_bought')}"
    elif category == ActionCenterCategory.CELL_PHONE:
        item_details = f"Phone: {item.get('phone_bought')}"
    
    prompt = f"""
    The user is asking for assistance with **{category_context}** on their **{card_name}**.
    
    TRANSACTION DETAILS:
    Retailer: {item.get('retailer')}
    Date: {item.get('date')}
    Total: ${item.get('total')}
    {item_details}
    
    USER'S SITUATION / ISSUE:
    "{user_notes}"
    
    TASK:
    Provide a **short, super concise, step-by-step instruction set** on how to proceed. 
    The output will be displayed in a mobile app, so formatting must be clean and minimal.
    
    - Focus on exactly what they need to do (e.g., "File a claim at [URL]", "Call 1-800-...", "Upload receipt").
    - Do not give generic advice if specific card details are known (infer from card name if possible, or give general best practice for that issuer).
    - Use clear headings or bullet points.
    """
    
    try:
        response = client.models.generate_content(
            model='gemini-3-pro-preview',
            contents=prompt,
        )
        
        instructions = response.text.strip()
        
        # 4. Save to DB
        auth.update_action_item(uid, category.value, item_id, {
            "help_requested": True,
            "gemini_instructions": instructions
        })
        
        return {"status": "success", "instructions": instructions}
        
    except Exception as e:
        print(f"Gemini Error: {e}")
        raise HTTPException(status_code=500, detail=f"AI Error: {str(e)}")

@router.post("/{category}/{item_id}/monitor", response_model=dict)
def toggle_price_monitoring(category: ActionCenterCategory, item_id: str, monitor: bool, current_user: dict = Depends(get_current_user)):
    """
    Enables/Disables price monitoring for an item.
    Only valid for Price Protection category ideally, but we'll allow it generally if the model supports it.
    """
    if category != ActionCenterCategory.PRICE_PROTECTION:
        raise HTTPException(status_code=400, detail="Price monitoring only available for Price Protection items.")
        
    uid = current_user['uid']
    auth.update_action_item(uid, category.value, item_id, {
        "monitor_price": monitor
    })
    
    return {"status": "success", "monitor_price": monitor}
